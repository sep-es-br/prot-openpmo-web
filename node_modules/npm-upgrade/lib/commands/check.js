'use strict';

exports.__esModule = true;
exports.handler = exports.describe = exports.aliases = exports.command = undefined;

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

exports.builder = builder;

var _fs = require('fs');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _opener = require('opener');

var _opener2 = _interopRequireDefault(_opener);

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _detectIndent2 = require('detect-indent');

var _detectIndent3 = _interopRequireDefault(_detectIndent2);

var _npmCheckUpdates = require('npm-check-updates');

var _npmCheckUpdates2 = _interopRequireDefault(_npmCheckUpdates);

var _versionUtil = require('npm-check-updates/lib/version-util');

var _catchAsyncError = require('../catchAsyncError');

var _catchAsyncError2 = _interopRequireDefault(_catchAsyncError);

var _npmProgress = require('../npmProgress');

var npmProgress = _interopRequireWildcard(_npmProgress);

var _filterUtils = require('../filterUtils');

var _packageUtils = require('../packageUtils');

var _changelogUtils = require('../changelogUtils');

var _cliTable = require('../cliTable');

var _cliStyles = require('../cliStyles');

var _askUser = require('../askUser');

var _askUser2 = _interopRequireDefault(_askUser);

var _ignore = require('./ignore');

var _Config = require('../Config');

var _Config2 = _interopRequireDefault(_Config);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const pkg = require('../../package.json');

function createUpdatedModulesTable(modules) {
  return (0, _cliTable.createSimpleTable)(_lodash2.default.map(modules, ({ name, from, to }) => [(0, _cliStyles.strong)(name), from, '→', (0, _versionUtil.colorizeDiff)(to, from)]));
}

const command = exports.command = 'check [filter]';
const aliases = exports.aliases = '*';
const describe = exports.describe = 'Check for outdated modules';

const depsCliOptions = _packageUtils.DEPS_GROUPS.filter(group => group.cliOption);

function builder(yargs) {
  depsCliOptions.forEach(({ name, field }) => yargs.option(name, {
    type: 'boolean',
    alias: name[0],
    describe: `check only "${field}"`
  }));
}

/* eslint complexity: "off" */
const handler = exports.handler = (0, _catchAsyncError2.default)((() => {
  var _ref = (0, _asyncToGenerator3.default)(function* (opts) {
    const filter = opts.filter;
    // Making function that will filter out deps by module name

    const filterModuleName = (0, _filterUtils.makeFilterFunction)(filter);

    // Checking all the deps if all of them are omitted
    if (_lodash2.default.every(depsCliOptions, function ({ name }) {
      return opts[name] === false;
    })) {
      _lodash2.default.each(depsCliOptions, function ({ name }) {
        return opts[name] = true;
      });
    }

    // Loading `package.json` from the current directory

    var _loadPackageJson = (0, _packageUtils.loadPackageJson)();

    const packageFile = _loadPackageJson.path,
          packageJson = _loadPackageJson.content,
          packageSource = _loadPackageJson.source;

    // Fetching remote changelogs db in background

    (0, _changelogUtils.fetchRemoteDb)();

    const depsGroupsToCheck = _lodash2.default.filter(depsCliOptions, function ({ name }) {
      return !!opts[name];
    });
    const depsGroupsToCheckStr = depsGroupsToCheck.length === depsCliOptions.length ? '' : `${_lodash2.default.map(depsGroupsToCheck, 'name').join(' and ')} `;
    const filteredWith = filter ? `filtered with ${(0, _cliStyles.strong)(filter)} ` : '';

    console.log(`Checking for outdated ${depsGroupsToCheckStr}dependencies ${filteredWith}for "${(0, _cliStyles.strong)(packageFile)}"...`);

    yield _npmCheckUpdates2.default.initialize();
    const currentVersions = _npmCheckUpdates2.default.getCurrentDependencies(packageJson, {
      prod: opts.production,
      dev: opts.development,
      optional: opts.optional
    });

    const latestVersions = yield _npmCheckUpdates2.default.queryVersions(currentVersions, { versionTarget: 'latest' });
    let upgradedVersions = _npmCheckUpdates2.default.upgradeDependencies(currentVersions, latestVersions);
    npmProgress.disable();

    // Filtering modules that have to be updated
    upgradedVersions = _lodash2.default.pickBy(upgradedVersions, function (newVersion, moduleName) {
      return filterModuleName(moduleName);
    });

    if (_lodash2.default.isEmpty(upgradedVersions)) {
      return console.log((0, _cliStyles.success)('All dependencies are up-to-date!'));
    }

    // Getting the list of ignored modules
    const config = new _Config2.default();
    config.ignore = config.ignore || {};

    // Making arrays of outdated modules

    var _$map$partition$value = (0, _lodash2.default)(upgradedVersions).map(function (newVersion, moduleName) {
      return {
        name: moduleName,
        from: currentVersions[moduleName],
        to: newVersion
      };
    }).partition(function (module) {
      return _lodash2.default.has(config.ignore, module.name) && _semver2.default.satisfies(latestVersions[module.name], config.ignore[module.name].versions);
    }).valueOf();

    const ignoredModules = _$map$partition$value[0],
          modulesToUpdate = _$map$partition$value[1];

    // Creating pretty-printed CLI tables with update info

    if (_lodash2.default.isEmpty(modulesToUpdate)) {
      console.log((0, _cliStyles.success)('\nAll active modules are up-to-date!'));
    } else {
      console.log(`\n${(0, _cliStyles.strong)('New versions of active modules available:')}\n\n${createUpdatedModulesTable(modulesToUpdate)}`);
    }

    if (!_lodash2.default.isEmpty(ignoredModules)) {
      const rows = _lodash2.default.map(ignoredModules, function ({ name, from, to }) {
        return [(0, _cliStyles.strong)(name), from, '→', (0, _versionUtil.colorizeDiff)(to, from), (0, _cliStyles.attention)(config.ignore[name].versions), config.ignore[name].reason];
      });

      // Adding table header
      rows.unshift(_lodash2.default.map(['', 'From', '', 'To', 'Ignored versions', 'Reason'], function (header) {
        return (0, _cliStyles.strong)(header);
      }));

      console.log(`\n${(0, _cliStyles.strong)('Ignored updates:')}\n\n${(0, _cliTable.createSimpleTable)(rows)}`);
    }

    const updatedModules = [];
    let isUpdateFinished = false;
    while (modulesToUpdate.length && !isUpdateFinished) {
      const outdatedModule = modulesToUpdate.shift();
      const name = outdatedModule.name,
            from = outdatedModule.from,
            to = outdatedModule.to;
      let changelogUrl = outdatedModule.changelogUrl,
          homepage = outdatedModule.homepage;

      // Adds new line

      console.log('');

      const answer = yield (0, _askUser2.default)({
        type: 'list',
        message: `${changelogUrl === undefined ? 'U' : 'So, u'}pdate "${name}" in package.json ` + `from ${from} to ${(0, _versionUtil.colorizeDiff)(to, from)}?`,
        choices: _lodash2.default.compact([{ name: 'Yes', value: true }, { name: 'No', value: false },
        // Don't show this option if we couldn't find module's changelog url
        changelogUrl !== null && { name: 'Show changelog', value: 'changelog' },
        // Show this if we haven't found changelog
        changelogUrl === null && homepage !== null && { name: 'Open homepage', value: 'homepage' }, { name: 'Ignore', value: 'ignore' }, { name: 'Finish update process', value: 'finish' }]),
        // Automatically setting cursor to "Open homepage" after we haven't found changelog
        default: changelogUrl === null && homepage === undefined ? 2 : 0
      });

      switch (answer) {
        case 'changelog':
          // Ask user about this module again
          modulesToUpdate.unshift(outdatedModule);

          if (changelogUrl === undefined) {
            console.log('Trying to find changelog URL...');
            changelogUrl = outdatedModule.changelogUrl = yield (0, _changelogUtils.findModuleChangelogUrl)(name);
          }

          if (changelogUrl) {
            console.log(`Opening ${(0, _cliStyles.strong)(changelogUrl)}...`);
            (0, _opener2.default)(changelogUrl);
          } else {
            console.log(`Sorry, we haven't found any changelog URL for ${(0, _cliStyles.strong)(name)} module.\n` + `It would be great if you could fill an issue about this here: ${(0, _cliStyles.strong)(pkg.bugs.url)}\n` + 'Thanks a lot!');
          }
          break;

        case 'homepage':
          // Ask user about this module again
          modulesToUpdate.unshift(outdatedModule);

          if (homepage === undefined) {
            console.log('Trying to find homepage URL...');
            homepage = outdatedModule.homepage = (0, _packageUtils.getModuleHomepage)((yield (0, _packageUtils.getModuleInfo)(name)));
          }

          if (homepage) {
            console.log(`Opening ${(0, _cliStyles.strong)(homepage)}...`);
            (0, _opener2.default)(homepage);
          } else {
            console.log(`Sorry, there is no info about homepage URL in the ${(0, _cliStyles.strong)(name)}'s package.json`);
          }
          break;

        case 'ignore':
          {
            var _ref2 = yield (0, _ignore.askIgnoreFields)(latestVersions[name]);

            const versions = _ref2.versions,
                  reason = _ref2.reason;

            config.ignore[name] = { versions, reason };
            break;
          }

        case 'finish':
          isUpdateFinished = true;
          break;

        case true:
          updatedModules.push(outdatedModule);
          (0, _packageUtils.setModuleVersion)(name, to, packageJson);
          delete config.ignore[name];
          break;
      }
    }

    // Adds new line
    console.log('');

    // Saving config
    config.save();

    if (!updatedModules.length) {
      console.log('Nothing to update');
      return;
    }

    // Showing the list of modules that are going to be updated
    console.log(`\n${(0, _cliStyles.strong)('These packages will be updated:')}\n\n` + createUpdatedModulesTable(updatedModules) + '\n');

    const shouldUpdatePackageFile = yield (0, _askUser2.default)({ type: 'confirm', message: 'Update package.json?', default: true });

    if (shouldUpdatePackageFile) {
      var _detectIndent = (0, _detectIndent3.default)(packageSource);

      const indent = _detectIndent.indent;


      (0, _fs.writeFileSync)(packageFile,
      // Adding newline to the end of file
      `${(0, _stringify2.default)(packageJson, null, indent)}\n`);
    }
  });

  return function (_x) {
    return _ref.apply(this, arguments);
  };
})());